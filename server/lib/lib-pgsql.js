require("dotenv").config();
const libShared = require("./lib-shared");
const { v4: uuidv4, validate: uuidValidate } = require("uuid");

const initOptions = {
  /**
   * @type {Boolean}
   * By Default is False
   */
  pgFormatting: false,

  /**
   * @type {Boolean}
   */
  pgNative: false,

  promiseLib: Promise,

  /**
   * Capitalizes any SQL generated by the library.
   * @type {Boolean}
   */
  capSQL: true,

  /**
   * @type {Boolean}
   */
  noWarnings: true,

  /**
   *
   * @param {Object} e Event Properties
   * @param {Object} e.client Client Object // $[pg.Client] object that represents the connection.
   * @param {any} e.dc // Database Context that was used when creating the database object (see {@link Database}).
   * @param {number} e.useCount
   * Number of times the connection has been previously used, starting with 0, for a freshly
   * allocated physical connection.
   */
  connect: (e) => {
    const cp = e.client.connectionParameters;
    // console.log("CP: ", cp);

    // console.log('Connected to database:', cp.database);
  },

  disconnect: (e) => {
    const cp = e.client.connectionParameters;
    // console.log('Disconnected from the database');
  },

  query: (e) => {
    // console.log('Query executed:', e.query);
  },

  receive: (data, result, e) => {
    // console.log('Data received:', data);
  },

  error: (error, e) => {
    // console.error('Database error:', error);
  },
};
const pgp = require("pg-promise")(initOptions);

const cn = {
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PWD,
};
const db = pgp(cn);

const pg = require("pg-promise")().pg;
const types = pg.types;
const moment = require("moment-timezone");
const { func } = require("joi");

// Parse PostgreSQL TIMESTAMP (OID 1114) without timezone into your desired timezone
types.setTypeParser(1114, (str) =>
  moment
    .tz(str, "YYYY-MM-DD HH:mm:ss", "Asia/Kuala_Lumpur")
    .format("YYYY-MM-DD HH:mm:ss")
);

// Optional: if you use TIMESTAMP WITH TIME ZONE, you can do this too
types.setTypeParser(1184, (str) =>
  moment.tz(str, "UTC").tz("Asia/Kuala_Lumpur").format("YYYY-MM-DD HH:mm:ss")
);

function pgSql() {}

Object.defineProperty(pgSql, "SQL_INSERT", {
  get: function () {
    return "INSERT INTO";
  },
});
Object.defineProperty(pgSql, "SQL_VALUE", {
  get: function () {
    return "VALUES";
  },
});

Object.defineProperty(pgSql, "SQL_UPDATE", {
  get: function () {
    return "UPDATE";
  },
});
Object.defineProperty(pgSql, "SQL_SET", {
  get: function () {
    return "SET";
  },
});

Object.defineProperty(pgSql, "SQL_DELETE", {
  get: function () {
    return "DELETE";
  },
});

Object.defineProperty(pgSql, "SQL_FROM", {
  get: function () {
    return "FROM";
  },
});
Object.defineProperty(pgSql, "SQL_WHERE", {
  get: function () {
    return "WHERE";
  },
});
Object.defineProperty(pgSql, "SQL_LEFTJ", {
  get: function () {
    return "LEFT JOIN";
  },
});
Object.defineProperty(pgSql, "SQL_ON", {
  get: function () {
    return "ON";
  },
});
Object.defineProperty(pgSql, "SQL_AND", {
  get: function () {
    return "AND";
  },
});
Object.defineProperty(pgSql, "SQL_OR", {
  get: function () {
    return "OR";
  },
});
Object.defineProperty(pgSql, "SQL_ORDER_BY", {
  get: function () {
    return "ORDRE BY";
  },
});

// Data Type (Postgres)
Object.defineProperty(pgSql, "SQL_INT", {
  get: function () {
    return "INT";
  },
});
Object.defineProperty(pgSql, "SQL_VARCHAR", {
  get: function () {
    return "VARCHAR";
  },
});
Object.defineProperty(pgSql, "SQL_TEXT", {
  get: function () {
    return "TEXT";
  },
});
Object.defineProperty(pgSql, "SQL_DATE", {
  get: function () {
    return "DATE";
  },
});
Object.defineProperty(pgSql, "SQL_DATETIME", {
  get: function () {
    return "DATETIME";
  },
});
Object.defineProperty(pgSql, "SQL_TIMESTAMP", {
  get: function () {
    return "TIMESTAMP";
  },
});
Object.defineProperty(pgSql, "SQL_UUID", {
  get: function () {
    return "UUID";
  },
});

// Data Type (Params)
Object.defineProperty(pgSql, "PARAMS_STRING", {
  get: function () {
    return "string";
  },
});
Object.defineProperty(pgSql, "PARAMS_INTEGER", {
  get: function () {
    return "int";
  },
});
Object.defineProperty(pgSql, "PARAMS_MONEY", {
  get: function () {
    return "money";
  },
});
Object.defineProperty(pgSql, "PARAMS_GUID", {
  get: function () {
    return "id";
  },
});
Object.defineProperty(pgSql, "PARAMS_DATE", {
  get: function () {
    return "dt";
  },
});
Object.defineProperty(pgSql, "PARAMS_DATETIME", {
  get: function () {
    return "dt2";
  },
});

Object.defineProperty(pgSql, "SQL_ACTION", {
  get: function () {
    return "fn_action_cmd";
  },
});

// Table
Object.defineProperty(pgSql, "COMPANY_PROFILE", {
  get: function () {
    return "tb_co";
  },
});
Object.defineProperty(pgSql, "AXN", {
  get: function () {
    return "tb_action"
  }
});
Object.defineProperty(pgSql, "USER_GROUP", {
  get: function () {
    return "tb_user_group";
  },
});
Object.defineProperty(pgSql, "GROUP_AXN", {
  get: function () {
    return "tb_user_group_action";
  },
});
Object.defineProperty(pgSql, "USER", {
  get: function () {
    return "tb_user";
  },
});
Object.defineProperty(pgSql, "LOG", {
  get: function () {
    return "tb_log";
  },
});
Object.defineProperty(pgSql, "SYS_SETUP", {
  get: function () {
    return "tb_sys_setup";
  },
});
Object.defineProperty(pgSql, "UAC_LOG", {
  get: function () {
    return "tb_uacc_log";
  },
});
Object.defineProperty(pgSql, "SUSPEND_LOG", {
  get: function () {
    return "tb_user_suspend_log";
  },
});

/**
 *
 * @param {String} tb_name
 * @param {String} sql
 * @param {Array} cols
 * @param {Array} params
 * @returns
 * // Normal Select Statement
 */
pgSql.getTable = async function (tb_name, sql, cols) {
  try {
    // Ensure table name is safe to use to prevent SQL injection
    if (!pgSql.validTbOrFn(tb_name)) {
      throw new Error("Invalid table name");
    }

    // Validate column names to prevent SQL injection
    if (!Array.isArray(cols) || !cols.every(pgSql.validColumnName)) {
      throw new Error("Invalid column names");
    }

    // Construct the SQL query dynamically
    const columnList = cols.join(", ");
    const query = `SELECT ${columnList} FROM ${tb_name} ${sql || ""}`;

    // Execute the query and return the result
    return await db.any(query);
  } catch (error) {
    console.error("Error in getTable:", error);
    throw error;
  }
};

/**
 * SELECT STATEMENT
 */
pgSql.statement = async function (query, params = []) {
  try {
    const data = await db.any(query, params);
    return data; // Return result instead of logging it
  } catch (err) {
    console.error("Error executing query:", err);
    throw err; // Rethrow error for better debugging
  }
};

/**
 * @param {String} name
 */
pgSql.validTbOrFn = function (name) {
  return /^[\w]+$/.test(name);
};

/**
 *
 * @param {Array} col
 * @returns
 */
pgSql.validColumnName = function (col) {
  const regex = /^(fn_[a-zA-Z_][a-zA-Z0-9_]*)|([a-zA-Z_][a-zA-Z0-9_]*)$/;
  return regex.test(col);
};

pgSql.validProcName = async function (proc_name) {
  const regex = /^(pr_[a-zA-Z_][a-zA-Z0-9_]*)|([a-zA-Z_][a-zA-Z0-9_]*)$/;
  return regex.test(proc_name);
};

// Run Function
pgSql.executeFunction = async function (fn_name, params) {
  try {
    // Ensure function name is safe to use
    if (!pgSql.validTbOrFn(fn_name)) {
      throw new Error("Invalid function name");
    }

    // Construct the SQL function call dynamically
    const query = pgp.as.format("SELECT * FROM $1:name($2:csv)", [
      fn_name,
      params,
    ]);

    const result = await db.any(query);

    // Execute the function and return the result
    return {
      data: result, // The result rows
      rowCount: result.length, // Number of rows
    };
  } catch (error) {
    console.error("Error in executeFunction:", error);
    throw error;
  }
};

pgSql.getAction = async function (axn_code) {
  try {
    // Call the function using db.func
    const result = await db.func(`${pgSql.SQL_ACTION}`, [axn_code]);

    // Return the result (which will be an array of rows)
    return {
      data: result,
      rowCount: result.length, // This is how you get the number of rows
    };
  } catch (error) {
    console.error("Error in fetching action:", error);
    throw error; // Re-throw the error so it can be handled further up the chain
  }
};

// Call Store Procedure
pgSql.executeStoreProc = async function (sp_name, params) {
  try {
    if (!pgSql.validProcName(sp_name)) {
      throw new Error("Invalid procedure name");
    }

    if (!Array.isArray(params)) {
      throw new Error("Parameters must be an array");
    }

    const query = pgp.as.format("CALL $1:name($2:csv)", [sp_name, params]);

    return await db.many(query);
  } catch (err) {
    console.error("Error in executeStoreProc:", err);
    throw err;
  }
};

pgSql.appendLog = async function (log_type, log_data) {
  try {
    await db.none(
      `
                INSERT INTO ${this.LOG} (
                
                ) VALUES (
                 
                )
            `,
      []
    );
  } catch (err) {
    throw err;
  }
};

// Add this function inside your pgSql object in the library
pgSql.runTransaction = async function (operations) {
  try {
    // Start a transaction using `db.tx` (transaction)
    const result = await db.tx(async (t) => {
      // Inside the transaction, `t` is the transaction context which behaves like `db`
      // `operations` is expected to be a function that will contain all transactional queries
      // Each operation will be executed using the `t` object to ensure it's part of the transaction.

      // Call the provided operations function and pass the transaction context
      return await operations(t);
    });

    // Return the result if everything goes fine
    return result;
  } catch (error) {
    console.error("Error occurred in transaction:", error);
    throw error; // Rethrow the error so it can be handled by the caller
  }
};

pgSql.emptyGuid = function () {
  return "00000000-0000-0000-0000-000000000000";
};

pgSql.fnToUuid = function (i) {
  try {
    if (!i) return this.emptyGuid();

    const value = String(i).toLowerCase();
    return uuidValidate(value) ? value : this.emptyGuid();
  } catch (err) {
    return this.emptyGuid();
  }
};

module.exports = { pgSql, db, pgp };
